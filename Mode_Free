`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Company: 
// Engineer: 
// 
// Create Date: 2023/12/15 19:58:59
// Design Name: 
// Module Name: Mode_Free
// Project Name: 
// Target Devices: 
// Tool Versions: 
// Description: 
// 
// Dependencies: 
// 
// Revision:
// Revision 0.01 - File Created
// Additional Comments:
// 
//////////////////////////////////////////////////////////////////////////////////


module Mode_Free(
 input wire clk,
   input wire write_on,
   input wire reset,
    input wire [6:0] keys,
    input wire [1:0]song_select,
   input wire [1:0] octave,
   input wire playRecord,
   input wire selectSong,
   output reg[3:0] note_to_play,
   output reg [1:0]octave_out
    );
    parameter Note_WIDTH = 4;  // 根据需要调整数据宽度
    parameter Time_WIDTH = 6; 
    parameter Octave_WIDTH = 3;  // 根据需要调整数据宽度
    parameter RAM_DEPTH = 1024; // RAM 深度
    parameter ADDR_WIDTH = 10;  // 地址宽度，用于遍历
    reg write_current_song = 0; // 用于选择当前写入的歌曲
    reg play_current_song = 0; // 用于选择当前播放的歌曲
  reg [1:0] data_out_octave;
   reg [Note_WIDTH-1:0] ram1 [0:RAM_DEPTH-1][0:2];
   reg [Time_WIDTH-1:0] ram2 [0:RAM_DEPTH-1][0:2];
   reg [Octave_WIDTH-1:0] ram3 [0:RAM_DEPTH-1][0:2];
   
   reg [ADDR_WIDTH-1:0][0:2] addr1 = 0;
   reg [ADDR_WIDTH-1:0][0:2] addr2 = 0;
   reg [ADDR_WIDTH-1:0][0:2] addr3 = 0;
    
    wire [Note_WIDTH-1:0] data_out_note;
    wire [Time_WIDTH-1:0] data_out_time;
    wire [ADDR_WIDTH-1:0] addr_write;
    wire checkNote;
    wire checkTime;
     
     writeToRam write_to_ram(
     .clk(clk),
     .write_on(write_on),
     .keys(keys),
     .data_in_octive(octave),
     .data_out_note(data_out_note),
     .data_out_time(data_out_time),
     .checkNote(checkNote),
     .checkTime(checkTime)
     );
     always@(negedge write_on)begin
     write_current_song <= (write_current_song + 1) % 3; // 写到下一首歌曲
     end
     //选择歌曲
     always@(selectSong)begin
     play_current_song <= (play_current_song + 1) % 3; // 切换到下一首歌曲播放
     end
     
     always @(posedge clk) begin
          data_out_octave<=octave;
     if(write_on)begin
     if(checkNote==1'b1 && checkTime==1'b1)begin
     ram1[addr_write][write_current_song] <= data_out_note;
     ram2[addr_write][write_current_song] <= data_out_time;
     ram3[addr_write][write_current_song] <= data_out_octave;
             end
           end      
         end
         
  reg i=0;
  reg count1=0;
always@(posedge clk )begin
if(!reset)begin
count1=count1+1;
if(count1<=ram2[i][play_current_song])
begin
note_to_play<=ram1[i][play_current_song];
octave_out=ram3[i][play_current_song];
end
else  i<=i+1;
end
else begin
 count1<=0;
 i<=0;
 
 end
  end  
endmodule
    
