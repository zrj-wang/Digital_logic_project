`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Company: 
// Engineer: 
// 
// Create Date: 2023/12/15 19:58:59
// Design Name: 
// Module Name: Mode_Free
// Project Name: 
// Target Devices: 
// Tool Versions: 
// Description: 
// 
// Dependencies: 
// 
// Revision:
// Revision 0.01 - File Created
// Additional Comments:
// 
//////////////////////////////////////////////////////////////////////////////////


module mode_free(
 input wire clk,
   input wire write_on,
    input wire storeRecord,
    input wire [6:0] keys,
    input wire [1:0]song_select,
   input wire [1:0] octave,
   input wire playState,//按一次开始播放，按第二次停止播放
   input wire [3:0]selectSong,
   output reg [6:0] led_out,
   output reg[3:0] note_to_play1,
   output reg [1:0]octave_out1,
    output reg[3:0] note_to_play2,
   output reg [1:0]octave_out2
    );
    
    parameter Note_WIDTH = 4;  // 根据需要调整数据宽度
    parameter Time_WIDTH = 6; 
    parameter Octave_WIDTH = 2;  // 根据需要调整数据宽度
    parameter RAM_DEPTH = 32; // RAM 深度
    parameter ADDR_WIDTH = 10;  // 地址宽度，用于遍历
    parameter  led1=7'b0000001,led2=7'b0000010,led3=7'b0000100,led4=7'b0001000,led5=7'b0010000,
    led6=7'b0100000,led7=7'b1000000,led8=7'b0000000,led_for_delete=7'b1111111;
    
    reg playState1;
   reg [1:0]write_current_song = 0; // 用于选择当前写入的歌曲
   reg play_current_song = 0; // 用于选择当前播放的歌曲
   reg [1:0] data_out_octave;
//使用RAM储存歌曲信息：ram1代表note信息 ram2代表time信息 ram3代表octave信息
   reg [Note_WIDTH-1:0] ram1[0:2] [0:RAM_DEPTH-1];
   reg [Time_WIDTH-1:0] ram2[0:2] [0:RAM_DEPTH-1];
   reg [Octave_WIDTH-1:0] ram3 [0:2][0:RAM_DEPTH-1];
   
   reg [ADDR_WIDTH-1:0] addr1[0:2] ;
   reg [ADDR_WIDTH-1:0] addr2[0:2];
   reg [ADDR_WIDTH-1:0] addr3[0:2];
    
    wire [Note_WIDTH-1:0] data_out_note;
    wire [Time_WIDTH-1:0] data_out_time;
    reg [ADDR_WIDTH-1:0] addr_write;
    wire checkNote;
    wire checkTime;
     
     writeToRam write_to_ram(
     .clk(clk),
     .write_on(write_on),
     .keys(keys),
     .data_in_octive(octave),
     .data_out_note(data_out_note),
     .data_out_time(data_out_time),
     .checkNote(checkNote),
     .checkTime(checkTime)
     );

     //选择歌曲
//     always@(posedge selectSong)begin
//     play_current_song <= (play_current_song + 1) % 3; // 切换到下一首歌曲播放
//     end

always@(selectSong)begin
case(selectSong)
4'b0100: play_current_song=0;
4'b0101: play_current_song=1;
4'b0110: play_current_song=2;
default:playState1=0;
endcase
end

     //写入歌曲信息
     always @(posedge clk) begin
          data_out_octave<=octave;
     if(write_on && addr_write<=2^(ADDR_WIDTH-1))begin
     if(checkNote==1'b1 && checkTime==1'b1)begin
     ram1[write_current_song][addr_write] <= data_out_note;
     ram2[write_current_song][addr_write] <= data_out_time;
     ram3[write_current_song][addr_write] <= data_out_octave;
     addr_write<=addr_write+1;
             end
           end      
         end



   //关闭录音键准备写入下一首歌
     always@(negedge write_on)begin
     write_current_song <= (write_current_song + 1) % 3; // 写到下一首歌曲
     end
   
//使用时钟来确定是否存储当前歌曲
     reg [31:0] counter1 = 0;  // N 是计数器的位宽
     reg store_clk = 0;
     parameter DIVIDE_VALUE1=200000;//设置慢速时钟的频率为clk的二十万分之一，也就是0.2秒一次升降沿
     always @(posedge clk) begin
         if (counter1 == DIVIDE_VALUE1-1) begin
             store_clk <= ~store_clk;
             counter1 <= 0;
         end
         else begin
          counter1 <= counter1 + 1;
          store_clk<=0;
         end
     end
     reg delete=0;
//如果按键超过两秒，存储录音,如果没到两秒，不存储该录音
reg [3:0] press_timer; // 4位计时器，用于计时按键按下的时间

always @(posedge store_clk) begin
    if (storeRecord) begin
        // 如果按钮按下，递增计时器
        if (press_timer < 4'b1110) begin
            press_timer <= press_timer + 1;
        end
    end 
    else begin
        // 如果按钮未按下，重置计时器
        press_timer <= 4'b0000;
    end

    // 检查计时器是否超过两秒，如果是，则设置 delete 为1，否则设置为0
    if (press_timer >= 4'b1010) begin
        delete = 1;
        addr_write<=0;
    end else begin
        delete = 0;
    end
end

//将开关值换为node
reg [3:0]note;
always@(*)begin
    case(keys)
    7'b0000001:begin note=4'b0001; led_out=led1; end
    7'b0000010:begin note=4'b0010; led_out=led2; end
    7'b0000100:begin note=4'b0011; led_out=led3; end
    7'b0001000:begin note=4'b0100; led_out=led4; end
    7'b0010000:begin note=4'b0101; led_out=led5; end
    7'b0100000:begin note=4'b0110; led_out=led6; end
    7'b1000000:begin note=4'b0111; led_out=led7; end
   default begin
    note=4'b0000;
    led_out=led8;
    end
endcase
if(delete==1)
led_out=led_for_delete;//用以指示放弃当前存储
end



//熄灭指示灯
parameter DIVIDE_VALUE=100000;//设置慢速时钟的频率为clk的十万分之一，也就是10Hz
reg[31:0] countDelete=0;
always@(posedge clk)begin
if(delete)begin
    if (countDelete == DIVIDE_VALUE-1) begin
        countDelete <= 0;
    end
    else begin
     countDelete <= countDelete + 1;end
    end
    end
//增加一个debounding方法去抗抖动,记录当前按键值
reg [31:0] counter = 0;  // N 是计数器的位宽
reg slow_clk = 0;
reg [31:0] counter_middle = 0;  // N 是计数器的位宽
reg middleslow_clk = 0;
parameter DIVIDE_VALUE_middle=500000;//设置中等慢速时钟的频率为clk的五十万分之一，也就是2Hz
always @(posedge clk) begin
    if (counter == DIVIDE_VALUE-1) begin
        slow_clk <= ~slow_clk;
        counter <= 0;
    end
    else begin
     counter <= counter + 1;
    end
    if (counter_middle == DIVIDE_VALUE_middle-1) begin
        middleslow_clk <= ~middleslow_clk;
        counter_middle <= 0;
    end
    else begin
     counter_middle <= counter_middle + 1;
    end
end

//直接输出
always@(posedge slow_clk)begin
 note_to_play1=note;
octave_out1=octave;
end



//使用playstate 控制播放暂停 song_select 选择播放的音乐

reg [31:0] i=0; // 在for循环之前声明i
reg [31:0] j=0; // 在for循环之前声明i
//判断是否播放录音
always@(posedge middleslow_clk)
if(playState1) begin
 
    note_to_play2<=ram1[play_current_song][i];
    octave_out2<=ram3[play_current_song][i];
   j<=j+1;
   i<=i+1;
end
else begin 
 note_to_play2<=3'b000;
   octave_out2<=2'b00;
end
endmodule
