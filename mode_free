`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Company: 
// Engineer: 
// 
// Create Date: 2023/12/15 19:58:59
// Design Name: 
// Module Name: Mode_Free
// Project Name: 
// Target Devices: 
// Tool Versions: 
// Description: 
// 
// Dependencies: 
// 
// Revision:
// Revision 0.01 - File Created
// Additional Comments:
// 
//////////////////////////////////////////////////////////////////////////////////


module mode_free(
 input wire clk,
   input wire write_on,
    input wire storeRecord,
    input wire [6:0] keys,
    input wire [1:0]song_select,
   input wire [1:0] octave,
   input wire playState,//按一次开始播放，按第二次停止播放
   input wire [3:0]selectSong,
   output reg [6:0] led_out,
   output reg[3:0] note_to_play1,
   output reg [1:0]octave_out1,
    output reg[3:0] note_to_play2,
   output reg [1:0]octave_out2
    );
    
    parameter Note_WIDTH = 4;  // 根据需要调整数据宽度
    parameter Time_WIDTH = 6; 
    parameter Octave_WIDTH = 2;  // 根据需要调整数据宽度
    parameter RAM_DEPTH = 32; // RAM 深度
    parameter ADDR_WIDTH = 10;  // 地址宽度，用于遍历
    parameter  led1=7'b0000001,led2=7'b0000010,led3=7'b0000100,led4=7'b0001000,led5=7'b0010000,
    led6=7'b0100000,led7=7'b1000000,led8=7'b0000000,led_for_store=7'b1111111,led_for_delete=7'b0001000;
    
    reg playState1;
   reg write_current_song = 0; // 用于选择当前写入的歌曲
   reg play_current_song = 0; // 用于选择当前播放的歌曲
   reg [1:0] data_out_octave;
//使用RAM储存歌曲信息：ram1代表note信息 ram2代表time信息 ram3代表octave信息
   reg [Note_WIDTH-1:0] ram1[0:2] [0:RAM_DEPTH-1];
   reg [Time_WIDTH-1:0] ram2[0:2] [0:RAM_DEPTH-1];
   reg [Octave_WIDTH-1:0] ram3 [0:2][0:RAM_DEPTH-1];
   
   reg [ADDR_WIDTH-1:0] addr1[0:2] ;
   reg [ADDR_WIDTH-1:0] addr2[0:2];
   reg [ADDR_WIDTH-1:0] addr3[0:2];
    
    wire [Note_WIDTH-1:0] data_out_note;
    wire [Time_WIDTH-1:0] data_out_time;
    wire [ADDR_WIDTH-1:0] addr_write;
    wire checkNote;
    wire checkTime;
     
     writeToRam write_to_ram(
     .clk(clk),
     .write_on(write_on),
     .keys(keys),
     .data_in_octive(octave),
     .data_out_note(data_out_note),
     .data_out_time(data_out_time),
     .checkNote(checkNote),
     .checkTime(checkTime)
     );

     //选择歌曲
//     always@(posedge selectSong)begin
//     play_current_song <= (play_current_song + 1) % 3; // 切换到下一首歌曲播放
//     end

always@(selectSong)begin
case(selectSong)
4'b0100: play_current_song=0;
4'b0101: play_current_song=1;
4'b0110: play_current_song=2;
default:playState1=0;
endcase
end

     //写入歌曲信息
     always @(posedge clk) begin
          data_out_octave<=octave;
     if(write_on)begin
     if(checkNote==1'b1 && checkTime==1'b1)begin
     ram1[write_current_song][addr_write] <= data_out_note;
     ram2[write_current_song][addr_write] <= data_out_time;
     ram3[write_current_song][addr_write] <= data_out_octave;
             end
           end      
         end



   //关闭录音键准备写入下一首歌
     always@(negedge write_on)begin
     write_current_song <= (write_current_song + 1) % 3; // 写到下一首歌曲
     end
   
//使用超慢时钟来确定是否存储当前歌曲
     reg [31:0] counter1 = 0;  // N 是计数器的位宽
     reg superslow_clk = 0;
     parameter DIVIDE_VALUE1=1500000;//设置慢速时钟的频率为clk的一百五十万分之一，也就是1.5秒一次升降沿
     always @(posedge clk) begin
         if (counter1 == DIVIDE_VALUE1-1) begin
             superslow_clk <= ~superslow_clk;
             counter1 <= 0;
         end
         else begin
          counter1 <= counter1 + 1;
         end
     end
//如果按键超过三秒，必存储到音乐库,如果没到三秒，不存储该录音
always@(posedge superslow_clk)begin
if(storeRecord)begin
 write_current_song <= write_current_song ;
 led_out=led_for_store;//用以指示已存储
end
else begin
 write_current_song <= (write_current_song + 2) % 3;
  led_out=led_for_delete;//用以指示放弃当前存储
end
end


//将开关值换为node
reg [3:0]note;
always@(*)begin
    case(keys)
    7'b0000001:begin note=4'b0001; led_out=led1; end
    7'b0000010:begin note=4'b0010; led_out=led2; end
    7'b0000100:begin note=4'b0011; led_out=led3; end
    7'b0001000:begin note=4'b0100; led_out=led4; end
    7'b0010000:begin note=4'b0101; led_out=led5; end
    7'b0100000:begin note=4'b0110; led_out=led6; end
    7'b1000000:begin note=4'b0111; led_out=led7; end
   default
    note=4'b0000;
endcase
end


//增加一个debounding方法去抗抖动,记录当前按键值
reg [31:0] counter = 0;  // N 是计数器的位宽
reg slow_clk = 0;
parameter DIVIDE_VALUE=100000;//设置慢速时钟的频率为clk的十万分之一，也就是10Hz
reg [31:0] counter_middle = 0;  // N 是计数器的位宽
reg middleslow_clk = 0;
parameter DIVIDE_VALUE_middle=500000;//设置中等慢速时钟的频率为clk的五十万分之一，也就是2Hz
always @(posedge clk) begin
    if (counter == DIVIDE_VALUE-1) begin
        slow_clk <= ~slow_clk;
        counter <= 0;
    end
    else begin
     counter <= counter + 1;
    end
    if (counter_middle == DIVIDE_VALUE_middle-1) begin
        middleslow_clk <= ~middleslow_clk;
        counter_middle <= 0;
    end
    else begin
     counter_middle <= counter_middle + 1;
    end
end

//直接输出
always@(posedge slow_clk)begin
 note_to_play1=note;
octave_out1=octave;
end



//使用playstate 控制播放暂停 song_select 选择播放的音乐

reg [31:0] i=0; // 在for循环之前声明i
reg [31:0] j=0; // 在for循环之前声明i
//判断是否播放录音
always@(posedge middleslow_clk)
if(playState1) begin
 
    note_to_play2<=ram1[play_current_song][i];
    octave_out2<=ram3[play_current_song][i];
   j<=j+1;
   i<=i+1;
end
else begin 
 note_to_play2<=3'b000;
   octave_out2<=2'b00;
end
endmodule
